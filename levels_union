// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © konslip

//@version=5
strategy("Levels union logic", overlay=true, initial_capital=100, calc_on_every_tick=false)

int volume_bar_amount = 30*3
int volume_level_cnt = 10*3
int volume_min_levels_in_cluster = 7*3

int minmax_window = 31
int minmax_center_bar = int(minmax_window / 2)
int minmax_min_levels_in_cluster = 4
float minmax_round_level_step = 0.01
int minmax_round_levels_cnt = 1000
float minmax_volume_thresh = 1.2
bool minmax_vol_filter_off = true

float max_level_rel_diff = 0.003

float risk_ratio = 2

var VolumeLevels = array.new_float(1, 1)

float min_level = 1000000000
float max_level = -1000000000

float nearest_up_level_top1 = na
float nearest_up_level_top2 = na
float nearest_up_level_top3 = na
float nearest_low_level_top1 = na
float nearest_low_level_top2 = na
float nearest_low_level_top3 = na

float level_price_top1 = na
float max_level_volumes = na
int max_level_index = 0
uniqueVolumeLevels = array.new_float()
valueCounts = array.new_int()

sma_levels = array.new_float()

atr = ta.atr(minmax_window)
current_bar_change = math.abs(close - open) 

get_clustered_levels(Levels) =>
    uniqueLevels = array.new_float()
    valueCounts = array.new_int()

    if Levels.size() > 0

        levels_in_cluster = array.new_float()
        first_level_price = -1.
        for i=0 to array.size(Levels)-1
            level_price = Levels.get(i)
            
            if first_level_price == -1.
                first_level_price := level_price

            rel_diff = level_price / first_level_price - 1

            if rel_diff < max_level_rel_diff
                levels_in_cluster.push(level_price)
            else
                cluster_price = array.avg(levels_in_cluster)
                cnt = array.size(levels_in_cluster)
                uniqueLevels.push(cluster_price)
                valueCounts.push(cnt)

                levels_in_cluster := array.new_float(1, level_price)
                first_level_price := level_price

        if levels_in_cluster.size() > 0
            cluster_price = array.avg(levels_in_cluster)
            cnt = array.size(levels_in_cluster)
            uniqueLevels.push(cluster_price)
            valueCounts.push(cnt)
    
    [uniqueLevels, valueCounts]

//i_from = input.time(defval = timestamp("28 Sep 2022 00:00 +0000"), title = "From")
//i_from = input.time(defval = timestamp("2 Aug 2018 00:00 +0000"), title = "From")
//i_from = input.time(defval = timestamp("17 Aug 2000 00:00 +0000"), title = "From")
//if time >= i_from

for i = 0 to volume_bar_amount-1
    if (hl2[i] > max_level)
        max_level := hl2[i]
    if (hl2[i] < min_level)
        min_level := hl2[i]

//float[] level_prices = na
level_prices = array.new_float()

for j = 0 to volume_level_cnt
    level_price = min_level + ((max_level - min_level) / volume_level_cnt) * j
    level_prices.push(level_price)

level_volumes = array.new_float(volume_level_cnt+1, 0)
for i = 1 to volume_bar_amount-1
    bar_h2l = hl2[i]
    nearest_index = 0

    for j = 0 to volume_level_cnt
        level_price = level_prices.get(j)
        if level_price >= bar_h2l
            nearest_index := j
            break

    accum_volume = level_volumes.get(nearest_index)
    accum_volume += volume[i] * ohlc4[i]
    level_volumes.set(nearest_index, accum_volume)


level_volumes_sorted = level_volumes.copy()
level_volumes_sorted.sort(order.descending)


max_level_volumes := level_volumes_sorted.get(0)
max_level_index := 0

max_level_volumes_top2 = level_volumes_sorted.get(1)
max_level_index_top2 = 0

max_level_volumes_top3 = level_volumes_sorted.get(2)
max_level_index_top3 = 0


for j = 0 to volume_level_cnt
    accum_volume = level_volumes.get(j)
    if max_level_volumes == accum_volume
        max_level_index := j
        
    if max_level_volumes_top2 == accum_volume
        max_level_index_top2 := j

    if max_level_volumes_top3 == accum_volume
        max_level_index_top3 := j


level_price_top1 := bar_index >= volume_level_cnt ? level_prices.get(max_level_index) : close
level_price_top2 = bar_index >= volume_level_cnt ? level_prices.get(max_level_index_top2) : close
level_price_top3 = bar_index >= volume_level_cnt ? level_prices.get(max_level_index_top3) : close

level_price_top1 := math.round_to_mintick(level_price_top1)

VolumeLevels.push(level_price_top1)
//VolumeLevels.push(level_price_top2)
//VolumeLevels.push(level_price_top3)

VolumeLevels.sort()

[uniqueVolumeLevels1, valueCounts1] = get_clustered_levels(VolumeLevels)
uniqueVolumeLevels := uniqueVolumeLevels1
valueCounts := valueCounts1

currentVolumeLevels = array.new_float()

for i=0 to array.size(uniqueVolumeLevels)-1
    cnt = valueCounts.get(i)
    if cnt >= volume_min_levels_in_cluster
        level_price = uniqueVolumeLevels.get(i)
        currentVolumeLevels.push(level_price)

currentVolumeLevels.sort()



round_levels = array.new_float() 
for i=1 to minmax_round_levels_cnt
    round_levels.push(i*minmax_round_level_step) // 100

var float[] MinMaxLevels = round_levels

lowest_low = ta.lowest(low, minmax_window)
highest_high = ta.highest(high, minmax_window)
avg_volume = ta.sma(volume, minmax_window)

center_volume = volume[minmax_center_bar]

center_low_level = low[minmax_center_bar]
if center_low_level == lowest_low and (center_volume > avg_volume * minmax_volume_thresh or minmax_vol_filter_off)
    MinMaxLevels.push(center_low_level)

center_high_level = high[minmax_center_bar]
if center_high_level == highest_high and (center_volume > avg_volume * minmax_volume_thresh or minmax_vol_filter_off)
    MinMaxLevels.push(center_high_level)

current_bar_volume = volume

if current_bar_change > atr * 2 and current_bar_volume > avg_volume * minmax_volume_thresh
    MinMaxLevels.push(low)
    MinMaxLevels.push(high)

bullishPinbarCondition = (high - close) / close < 0.01 and (high - open) / open < 0.01 and (high - low) / low > 0.03
if bullishPinbarCondition and current_bar_volume > avg_volume * minmax_volume_thresh
    MinMaxLevels.push(low)

bearishPinbarCondition = (close - low) / low < 0.01 and (open - low) / low < 0.01 and (high - low) / low > 0.03
if bearishPinbarCondition and current_bar_volume > avg_volume * minmax_volume_thresh
    MinMaxLevels.push(high)

MinMaxLevels.sort()

[uniqueMinMaxLevels, cnts] = get_clustered_levels(MinMaxLevels)

currentMinMaxLevels = array.new_float()

for i=0 to uniqueMinMaxLevels.size()-1
    if cnts.get(i) >= minmax_min_levels_in_cluster
        currentMinMaxLevels.push(uniqueMinMaxLevels.get(i))

Levels = array.concat(currentVolumeLevels, currentMinMaxLevels)
//Levels = currentVolumeLevels
//Levels = currentMinMaxLevels
Levels.sort()
[uniqueLevels, _] = get_clustered_levels(Levels)
Levels := uniqueLevels
Levels.sort()

sma_levels := array.new_float()
for i=0 to 2
    sma_levels.push(ta.sma(close, int(50*math.pow(2, i))))

//Levels := array.concat(Levels, sma_levels)
Levels.sort()

//float nearest_up_level_top1 = na
//float nearest_up_level_top2 = na
//float nearest_up_level_top3 = na
if array.size(Levels) > 0
    for i=0 to array.size(Levels)-1
        level_price = Levels.get(i)
        if level_price > high
            nearest_up_level_top1 := level_price
            if Levels.size() > i+1 and i < Levels.size()-1
                nearest_up_level_top2 := Levels.get(i+1)
            if Levels.size() > i+2 and i < Levels.size()-2
                nearest_up_level_top3 := Levels.get(i+2)
            break

//float nearest_low_level_top1 = na
//float nearest_low_level_top2 = na
//float nearest_low_level_top3 = na
float nearest_low_level_top4 = na
if array.size(Levels) > 0
    for i=array.size(Levels)-1 to 0
        level_price = Levels.get(i)
        if level_price < low
            nearest_low_level_top1 := level_price
            if Levels.size() > i-1 and i > 1
                nearest_low_level_top2 := Levels.get(i-1)
            if Levels.size() > i-2 and i > 2
                nearest_low_level_top3 := Levels.get(i-2)
            if Levels.size() > i-3 and i > 3
                nearest_low_level_top4 := Levels.get(i-3)
            break

plot(nearest_up_level_top1, color = color.yellow, style=plot.style_stepline)
plot(nearest_up_level_top2, color = color.yellow, style=plot.style_stepline)
plot(nearest_up_level_top3, color = color.yellow, style=plot.style_stepline)
plot(nearest_low_level_top1, color = color.orange, style=plot.style_stepline)
plot(nearest_low_level_top2, color = color.orange, style=plot.style_stepline)
plot(nearest_low_level_top3, color = color.orange, style=plot.style_stepline)

